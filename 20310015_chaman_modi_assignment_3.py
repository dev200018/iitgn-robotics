# -*- coding: utf-8 -*-
"""20310015_Chaman_Modi_Assignment_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xCryY38wYTZFyiqqvkhUJZ-Fl3TuZXzi

## **ME 639: Introduction to Robotics | Assignment - 3**
##### Chaman Modi | 20310015

### Necessary functions is defined in this section.
"""

# Importing libraries and creating basic rotation functions
import numpy as np
import scipy as sci
import sympy as sp
sp.init_printing()
import matplotlib.pyplot as plt
import math

# Basic rotation matrices for rotation about x, y and z axes are as follows:
Rx,Ry,Rz,theta = sp.symbols('Rx,Ry,Rz,theta')

Rx = sp.Array([
                [1,0,0,0],
                [0,sp.cos(theta),-sp.sin(theta),0],
                [0,sp.sin(theta),sp.cos(theta),0],
                [0,0,0,1]
                ])

Ry = sp.Array([
                [sp.cos(theta),0,sp.sin(theta),0],
                [0,1,0,0],
                [-sp.sin(theta),0,sp.cos(theta),0],
                [0,0,0,1]
                ])

Rz = sp.Array([
                [sp.cos(theta),-sp.sin(theta),0,0],
                [sp.sin(theta),sp.cos(theta),0,0],
                [0,0,1,0],
                [0,0,0,1]
                ])

# Basic translation matrices for translation along x, y and z axes are as follows:
Tx,Ty,Tz,dist = sp.symbols('Tx,Ty,Tz,dist')
Tx = sp.Array([
                [1,0,0,dist],
                [0,1,0,0],
                [0,0,1,0],
                [0,0,0,1]
                ])

Ty = sp.Array([
                [1,0,0,0],
                [0,1,0,dist],
                [0,0,1,0],
                [0,0,0,1]
                ])

Tz = sp.Array([
                [1,0,0,0],
                [0,1,0,0],
                [0,0,1,dist],
                [0,0,0,1]
                ])

# Rotation matrix for rotation about an arbitrary axis k = [kx ky kz]' by angle theta
kx,ky,kz,theta = sp.symbols('kx,ky,kz,theta')
ct = sp.cos(theta)
st = sp.sin(theta)
vt = 1-sp.cos(theta)
Rk = sp.Array([
                [kx**2*vt*ct, kx*ky*vt-kz*st, kz*kz*vt+ky*st],
                [kx*ky*vt+kz*st, ky**2*vt+ct, ky*kz*vt-kx*st],
                [kx*kz*vt-ky*st, ky*kz*vt+kx*st, kz**2*vt+ct]
                ])

# Axis angle representation
def axis_angle(R):
  theta = np.arccos((R.trace()-1)/2)
  k = (1/(2*np.sin(theta)))*np.array([
                                      [R[2][1]-R[1][2]],
                                      [R[0][2]-R[2][0]],
                                      [R[1][0]-R[0][1]]
                                    ])
  return [k, theta]

"""## **Solution 3**
### Developed code is generalised self explainatory and equiped with the comments. It takes $n,DH_{data},\rho,q_{dot}$ as input and gives the following outputs in the sequential order:
1. Final matrix of end effector
2. Orientation matrix of end effector
3. Position vector of end effector
4. Jacobian matrix of end effector
5. End effector velocity

where,
> $n$ = no of links\
$DH_{data}$ = DH parameters in tabular format (Keep the column order in mind)\
$\rho$ = List indication type of joints (R = 1, P = 0)\
$q_{dot}$ = List of joint velocities





"""

def DH_results(n,DH_data,rho,q_dot):
  # Here, n represents the number of links.
  # DH_data represents the matrix having DH parameters
  # Size of DH_data should be n x 4
  # Order of arguments in DH_data will be [a_i,alpha_i,d_i,theta_i]
  # rho is an array indicating types of joints. For example, for RRP rho = [1,1,0]
  # q_dot is array containing joint velocities in logical sequence

  # Initialization of variables
  A = [0]*n
  T0 = [0]*n
  j = [0]*n
  temp = np.identity(4)
  z = [0]*(n+1)
  O = [0]*(n+1)
  
  # Initialization of variable z and O used in jacobian matrix
  # Assumption involved here: O0 = [[0],[0],[0]] and z0 = [[0],[0],[1]]
  # This assumption gets satisfied automatically when we use DH convention

  z[0] = np.array([[0],[0],[1]])
  O[0] = np.array([[0],[0],[0]])

  for i in range(n):
    A[i] = np.array(Rz.subs(theta,DH_data[i,3])) @ np.array(Tz.subs(dist,DH_data[i,2])) @ np.array(Tx.subs(dist,DH_data[i,0])) @ np.array(Rx.subs(theta,DH_data[i,1]))
    T0[i] = temp @ A[i]
    temp = T0[i]
    z[i+1] = np.transpose(np.array([T0[i][0:3,2]]))
    O[i+1] = np.transpose(np.array([T0[i][0:3,3]]))

  # Orientation and Position of end effector is given by
  Orient = T0[-1][0:3,0:3]
  Pos = np.transpose(np.array([T0[-1][0:3,3]]))
    
  # J is Jacobian matrix
  J = []
  if (rho==[]):
    for i in range(n):    
      J = np.append(J,np.transpose(np.array([np.append(np.cross(np.transpose(z[i]),np.transpose(O[-1]-O[i])),z[i])])))
      
  elif (len(rho)!=n):
    print("rho is defined incorrectly")
  else:
    for i in range(n):
      if (rho[i]==1):
        J = np.append(J,np.transpose(np.array([np.append(np.cross(np.transpose(z[i]),np.transpose(O[-1]-O[i])),z[i])])))
      elif (rho[i]==0):
        J = np.append(J,np.transpose(np.array([np.append(z[i],[[0],[0],[0]])])))

  J = np.transpose(J.reshape(n,6))

  if (len(q_dot)!=n):
    print('q_dot is defined incorrectly.')
  else:
    vel_vec = np.transpose(np.array([J @ q_dot]))

  return T0[-1],Orient,Pos,J,vel_vec

"""## **Solution 4**
> **$1.$  Stanford manipulator (RRP)**

"""

# initializing the variables
theta_1,theta_2,theta_4,theta_5,theta_6,d2,d3,d6 = sp.symbols('theta_1,theta_2,theta_4,theta_5,theta_6,d2,d3,d6')

# Althought only 3 links are there, but we consider 6 links on account of spherical wrist.
n = 6

# DH_data table for Stanford manipulator
DH_data = sp.Array([
                    [0,-np.pi/2,0,theta_1],
                    [0,np.pi/2,d2,theta_2],
                    [0,0,d3,0],
                    [0,-np.pi/2,0,theta_4],
                    [0,np.pi/2,0,theta_5],
                    [0,d6,0,theta_6],                    
                  ])

# Defining the joint type R = 1, P = 0
rho = [1,1,0,1,1,1]

# Let's take joint velocity vector as zero vector for the time being
q_dot = [0,0,0,0,0,0]

Final_Matrix,Orient,Position,Jacob,End_effector_vel = DH_results(n,DH_data,rho,q_dot)

"""***Final matrix of end effector***"""

sp.simplify(Final_Matrix)

"""***Orientation matrix of end effector***"""

sp.simplify(Orient)

"""***Position vector of end effector***"""

sp.simplify(Position)

"""***Jacobian matrix of end effector***"""

sp.simplify(Jacob)

"""***Velocity vector of end effector***"""

sp.simplify(End_effector_vel)

"""> **$2.$  SCARA manipulator (RRP)**"""

# initializing the variables
theta_1,theta_2,theta_4,a1,a2,d3,d4 = sp.symbols('theta_1,theta_2,theta_4,a1,a2,d3,d4')

# n is no of links
n = 4

# DH_data table for SCARA manipulator
DH_data = sp.Array([
                    [a1,0,0,theta_1],
                    [a2,np.pi,0,theta_2],
                    [0,0,d3,0],
                    [0,0,d4,theta_4]                    
                  ])

# Defining the joint type R = 1, P = 0
rho = [1,1,0,1]

# Let's take joint velocity vector as zero vector for the time being
q_dot = [0,0,0,0]

Final_Matrix,Orient,Position,Jacob,End_effector_vel = DH_results(n,DH_data,rho,q_dot)

"""***Final matrix of end effector***"""

sp.simplify(Final_Matrix)

"""***Orientation matrix of end effector***"""

sp.simplify(Orient)

"""***Position vector of end effector***"""

sp.simplify(Position)

"""***Jacobian matrix of end effector***"""

sp.simplify(Jacob)

"""***Velocity vector of end effector***"""

sp.simplify(End_effector_vel)

"""## **Solution 5**
*Textbook problem 3-7* is worked out by hand calculation and using the code developed previously. Results obtained through both approaches matches well.
"""

# initializing the variables
d1,d2,d3 = sp.symbols('d1,d2,d3')

# n is no of links
n = 3

# DH_data table for SCARA manipulator
DH_data = sp.Array([
                    [0,np.pi/2,d1,np.pi/2],            
                    [0,-np.pi/2,d2,np.pi/2],
                    [0,0,d3,-np.pi/2],         
                  ])

# Defining the joint type R = 1, P = 0
rho = [0,0,0]

# Let's take joint velocity vector as zero vector for the time being
q_dot = [0,0,0]

Final_Matrix,Orient,Position,Jacob,End_effector_vel = DH_results(n,DH_data,rho,q_dot)

"""***Final matrix of end effector***"""

sp.simplify(Final_Matrix)

"""***Orientation matrix of end effector***"""

sp.simplify(Orient)

"""***Position vector of end effector***"""

sp.simplify(Position)

"""***Jacobian matrix of end effector***"""

sp.simplify(Jacob)

"""***Velocity vector of end effector***"""

sp.simplify(End_effector_vel)

"""## **Solution 6**
*Textbook problem 3-8* is worked out by hand calculation and using the code developed previously. Results obtained through both approaches matches perfectly.
"""

# initializing the variables
a1,a2,a3,a6,theta_1,theta_2,theta_3,theta_4,theta_5,theta_6 = sp.symbols('a1,a2,a3,a6,theta_1,theta_2,theta_3,theta_4,theta_5,theta_6')

# n is no of links
n = 6

# DH_data table for SCARA manipulator
DH_data = sp.Array([
                    [0,np.pi/2,a1,theta_1],            
                    [a2,0,0,theta_2],
                    [a3,0,0,theta_3],
                    [0,-np.pi/2,0,theta_4],
                    [0,np.pi/2,0,theta_5] ,
                    [0,0,a6,theta_6]        
                  ])

# Defining the joint type R = 1, P = 0
rho = [1,1,1,1,1,1]

# Let's take joint velocity vector as zero vector for the time being
q_dot = [0,0,0,0,0,0]

Final_Matrix,Orient,Position,Jacob,End_effector_vel = DH_results(n,DH_data,rho,q_dot)

"""***Final matrix of end effector***"""

sp.simplify(Final_Matrix)

"""***Orientation matrix of end effector***"""

sp.simplify(Orient)

"""***Position vector of end effector***"""

sp.simplify(Position)

"""***Jacobian matrix of end effector***"""

sp.simplify(Jacob)

"""***Velocity vector of end effector***"""

sp.simplify(End_effector_vel)

"""## **Solution 11**
For drivation of equation of motion, a generalised code is developed, which takes $D(q)$, $V(q)$ and $\tau$ as input and gives a matrix containing equations of motion as output. After developing code a example is taken to check correctness of code. Generated equations matches perfectly with the equations acheived manually.

"""

# For writing dynamic equilibrium equation we need D(q), C(q,q_dot), g(q) and tau_k
# Below defined code gives these output in matrix formate

def dynamic_motion_eqn(D,V,tau):                    # D(q) is n x n matrix and V(q) is potential energy expression
  n = np.size(D,0)                              # n is any one dimension of D          
  c = sp.MutableDenseNDimArray([[[0]*n]*n]*n)   # c denotes christoffel symbols
  t = sp.Symbol('t')                            # time (t) is defined as symbolic variable
  q = sp.zeros(1,n)                          
  q_dot = sp.zeros(1,n)                         
  q_dot_dot = sp.zeros(1,n)                     
  for i in range(n):
    q[i] = sp.Function('q%d'%(i+1))(t)          # Initalization of q1, q2 . . . qn as function of t
    q_dot[i] = sp.diff(q[i],t)                  # Initalization of q1_dot, q2_dot . . . qn_dot as function of t
    q_dot_dot[i] = sp.diff(q_dot[i],t)          # Initalization of q1_dot_dot, q2_dot_dot . . . qn_dot_dot as function of t
  
  phi = sp.zeros(n,1)                           # Initialization of phi which is equal to dV/dq_k

  # For determination of christoffel symbols
  for k in range(n):
    phi[k] = sp.diff(V,q[k])                    
    for i in range(n):
      for j in range(n):
        c[k,i,j] = 0.5*(sp.diff(D[k,j],q[i])+sp.diff(D[k,i],q[j])-sp.diff(D[i,j],q[k]))
  
  eqn = sp.zeros(1,n)
  # Formation of dynamic equilibrium equations
  for k in range(n):
    t1 = 0
    t2 = 0
    for j in range(n):
      t1 = t1 + D[k,j]*q_dot_dot[j]
      for i in range(n):
        t2 = t2 + c[k,i,j]*q_dot[i]*q_dot[j]
    eqn[k] = sp.Eq(t1+t2+phi[k]-tau[k],0)

  return eqn

"""#### **Example:**
Let's take $D(q) = 
\begin{bmatrix}cos(q_1) & cos(_1)sin(q_2)\\cos(q_1)sin(q_2) & sin(q_1)cos(q_2)\end{bmatrix}$ , $V(q) = cos(q_1) sin(q_2) + q_1q_2$ and $\tau = \begin{bmatrix}0\\0\end{bmatrix}$ \





Based on these expressions, dynamic equations of motion is generated and varified.
"""

# Example for checking the code
n = 2
t = sp.Symbol('t')  
q = sp.zeros(1,n)
tau = sp.zeros(1,n)       # tau (torque) can be defined here, if non-zero.

# Intialization of required symbolic variables
for i in range(n):
  q[i] = sp.Function('q%d'%(i+1))(t)

# Input of D(q) should be made below
D = sp.Array([
              [    sp.cos(q[0]),        sp.cos(q[0])*sp.sin(q[1])],
              [sp.cos(q[0])*sp.sin(q[1]), sp.sin(q[0])*sp.cos(q[1])]
              ])

# Input of V(q) should be made below
V = sp.cos(q[0])*sp.sin(q[1]) + q[0]*q[1]

eqns = dynamic_motion_eqn(D,V,tau)

eqns[0]

eqns[1]